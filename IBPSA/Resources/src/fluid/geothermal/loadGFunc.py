# -*- coding: utf-8 -*-
"""
Created on Tue Sep 11 14:14:43 2018

@author: u0112721
"""

from __future__ import absolute_import, division, print_function

import numpy as np
import datetime
import pygfunction as gt
from scipy.constants import pi
from scipy.integrate import quad
from scipy.interpolate import interp1d
from scipy.special import j0, j1, y0, y1, exp1
import matplotlib.pyplot as plt
from matplotlib.ticker import AutoMinorLocator
import pandas as pd


def writeRecord(tSer,gFunc):

    #Author
    #author = input('Insert your name, for documentation purposes:')
    author = 'Iago Cupeiro'
    #Date of generation
    date = str(datetime.date.today())

	#Preliminary checks
    if not len(tSer) == len(gFunc):
        raise Exception('Size of time series and g-function values are not equal')
    elif not (tSer[0] == 0 and gFunc[0] == 0):
        raise Exception('Initial values are not set to zero') 

    # Build the full name of the record, including the configuration, number of holes,
    # distribution and spacing
    # TO-DO
    name = 'SquareConfig_9bor_3x3_B6'
    path = name + '.mo'

    with open(path, 'w') as f:
        f.write('within IBPSA.Fluid.Geothermal.Borefields.Data.GFunctions;\n')
        f.write('record ' + name +'\n')
        f.write('extends IBPSA.Fluid.Geothermal.Borefields.Data.GFunctions.Template('
            + '\n')
        f.write('    timExp={\n')
        for timExp in tSer[:-1]:
            f.write('    ' + str(timExp) + ',\n')
        f.write('    ' + str(tSer[-1]) + '},\n')
        f.write('    gFunc={\n')
        for gFun in gFunc[:-1]:
            f.write('    ' + str(gFun) + ',\n')
        f.write('    ' + str(gFunc[-1]) + '}\n')
        f.write('    );\n')

        f.write('  annotation (\n')
        f.write('    defaultComponentPrefixes = "parameter",\n')
        f.write('    defaultComponentName="gFunc",\n')
        f.write('  Documentation(info="<html>\n')
        f.write('<p>\n')
        f.write('Generated by ' + author + ' on ' + date + '.\n')
        f.write('</p>\n')
        f.write('</html>"));\n')
        f.write('end ' + name + ';')


def cyclicGFunc(time, gFunc, time2, gFunc2, nYears):
    gFuncCyclic = np.zeros_like(gFunc)
    y = 8760*3600.  # 1 year
    f = interp1d(time2, gFunc2)

    for i in range(len(gFunc)):
        if time[i] < y:
            for j in range(nYears):
                gFuncCyclic[i] = gFuncCyclic[i] + f(time[i]+j*y) - f(j*y)
        else:
            gFuncCyclic[i] = f(time[i]+(nYears-1)*y)
    
    return gFuncCyclic


def averageGFunc(time, gFunc, time2, gFunc2, nYears):
    gFuncAverage = 1./nYears*gFunc
    for n in range(2, nYears+1):
        gFuncAverage += 1./nYears*cyclicGFunc(time, gFunc, time2, gFunc2, n)
    
    return gFuncAverage


def shortTermCorrection(time, gFunc, r_b, aSoi):
    
    def _CHS(u, Fo, p):
        CHS_integrand = 1./(u**2*pi**2)*(np.exp(-u**2*Fo) - 1.0) / (j1(u)**2 + y1(u)**2) * (j0(p*u)*y1(u) - j1(u)*y0(p*2))
        return CHS_integrand
    
    def _ILS(t, aSoi, dis):
        ILS = exp1(dis**2/(4*aSoi*t))
        return ILS

    for i in range(len(time)):
        ILS = _ILS(time[i], aSoi, r_b)
        CHS, err = quad(
            _CHS, 1e-12, 100., args=(aSoi*time[i]/r_b**2, 1.))
        gFunc[i] = gFunc[i] + 2*pi*CHS - 0.5*ILS

    return gFunc


def main():
    # -------------------------------------------------------------------------
    # Simulation parameters
    # -------------------------------------------------------------------------

    # Borehole dimensions
    D = 0.0             # Borehole buried depth (m)
    H = 48           # Borehole length (m)
    r_b = 0.075         # Borehole radius (m)
    B = 5.0             # Borehole spacing (m)

    # Soil thermal properties
    kSoi = 1.25				# Ground thermal conductivity (W/(mK))
    cSoi = 1200				# Specific heat capacity of the soil (J/(kgK))
    dSoi = 1800				# Density of the soil (kg/m3)
    aSoi = kSoi/cSoi/dSoi   # Ground thermal diffusivity (m2/s)


    # Number of segments per borehole
    nSegments = 10

    # Geometrically expanding time vector. 

    nt = 75						   # Number of time steps
    ts = H**2/(9.*aSoi)            # Bore field characteristic time
    #ttsMax = np.exp(5)
    ydes = 10						# Design projected period (years)
    dt = 3600.		                # (Control) Time step (s)
    tmax = ydes * 8760. * 3600.     # Maximum time
    #tmax = ttsMax*ts                # Maximum time

    time = gt.utilities.time_geometric(dt, tmax, nt)
    time2 = gt.utilities.time_geometric(dt, tmax+(ydes-1)*8760.*3600., 2*nt)
    # -------------------------------------------------------------------------
    # Borehole fields
    # -------------------------------------------------------------------------

    # Field definition
    N_1 = 4
    N_2 = 4
    nBor = 16
    boreField = gt.boreholes.rectangle_field(N_1, N_2, B, B, H, D, r_b)
    gFunc = gt.gfunction.uniform_temperature(boreField, time, aSoi, nSegments=nSegments, disp=True)
    gFunc = shortTermCorrection(time, gFunc, r_b, aSoi)
    gFunc = gFunc / (2*np.pi*kSoi*H*nBor)
    gFunc2 = gt.gfunction.uniform_temperature(boreField, time2, aSoi, nSegments=nSegments, disp=True)
    gFunc2 = shortTermCorrection(time2, gFunc2, r_b, aSoi)
    gFunc2 = gFunc2 / (2*np.pi*kSoi*H*nBor)

    #Adding zero as the first element
    time = np.insert(time, 0, 0)
    gFunc = np.insert(gFunc, 0, 0)
    time2 = np.insert(time2, 0, 0)
    gFunc2 = np.insert(gFunc2, 0, 0)

    gFuncCyclic = cyclicGFunc(time, gFunc, time2, gFunc2, ydes)
    gFuncAverage = averageGFunc(time, gFunc, time2, gFunc2, ydes)

    writeRecord(time,gFuncAverage)

    # -------------------------------------------------------------------------
    # Figure
    # -------------------------------------------------------------------------

    plt.rc('figure')
    fig = plt.figure()
    ax1 = fig.add_subplot(111)
    # Axis labels
    ax1.set_xlabel(r'$ln(t/t_s)$')
    ax1.set_ylabel(r'$g(t/t_s)$')
    # Axis limits
    ax1.set_xlim([-10.0, 5.0])
    ax1.set_ylim([0., 20.])
    # Show minor ticks
    ax1.xaxis.set_minor_locator(AutoMinorLocator())
    ax1.yaxis.set_minor_locator(AutoMinorLocator())
    # Adjust to plot window
    plt.tight_layout()
    # Draw g-function
    ax1.plot(np.log(time[1:]/ts), gFunc[1:]*(2*np.pi*kSoi*H*nBor), 'k-', lw=1.5, label='Regular')
    ax1.plot(np.log(time[1:]/ts), gFuncCyclic[1:]*(2*np.pi*kSoi*H*nBor), 'r--', lw=1.5, label='Cyclic')
    ax1.plot(np.log(time[1:]/ts), gFuncAverage[1:]*(2*np.pi*kSoi*H*nBor), 'r-o', lw=1.5, label='Average')
    ax1.legend(loc='upper left')

    plt.show()

    return


# Main function
if __name__ == '__main__':
    main()